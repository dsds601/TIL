# 프록시

* Member를 조회할때 Teame도 같이 조회해야 할까?

  * 특정 메서드를 사용할때 team에 관한 데이터가 필요없을때 메모리를 낭비하면서 다 같이 쿼리를 보낼 필요가 없다.
  * **위 내용을 보완한게 지연로딩**이란게 있는데 지연로딩 이해를 위해서 프록시를 이해해야합니다.
  * em.find() : 데이터베이스를 통한 실제 엔티티 객체 조회
  * em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    * => DB에 쿼리가 안나가고 객체 조회

  ~~~java
  Member findMember = em.getReference(Member.class,mebmer.getId()); // <- 이때는 쿼리가 안나간다.
  //findMember.getClass() <- 실제 엔티티객체클래스가 아니라 하이버네이트에 프록시클래스
  sysout(findMember.getId()) // <- 실제 엔티티에 접근할때 쿼리가 사용됨
  ~~~

* ### 프록시 특징

  * 실제 클래스를 **상속**받아서 만들어짐 , 실제 클래스와 겉 모양이 같음 사용자 입장에서는 구분하지 않고 사용하면 됨

  * 프록시객체의 target이라는 변수에 Emtity에 참조값을 보관하고 잇다 프록시객체를 호출하면 그때 실제 객체의 메소드를 찾아가 호출함

  * ### 프록시 객체의 초기화

  ~~~java
  Member findMember = em.getReference(Member.class,mebmer.getId());
  member.getName();
  ~~~

  * 1. 프록시 객체의 메서드 사용
    2. 프록시에 entity에 실제 엔티티에 참조가 으므로 영속성 컨텍스트에 엔티티조회 요청
    3. 영속성 컨텍스트는 db를 통해 엔티티 조회
    4. 실제 entity생성
       1. DB조회후 프록시 target에 엔티티가 생성되어 참조값을 받게 되면 다시 DB조회할 이유 없음 -> 쿼리가 나가지 않음
    5. target에 엔티티를 연결하여 target.getName() 실제 주소에 메서드를 사용하여 조회

  * ### 정리

    * 프록시 객체는 처음 사용시 한번만 초기화

    * 프록시 객체가 초기화 할때 실제 엔티티로 바뀌는건 아님 초기화후 실제 엔티티에 접근이 가능한것일 뿐

    * 프록시 객체는 원본 엔티티를 상속 받아서 == 비교시 프록시가 아닌 엔티티랑 프록시 비교시 타입이 맞지않는다고 나옴 **실제 타입 비교시에는 instance of 사용 -> m1 instanceof Member**

    * 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.gerReference()를 호출해도 실제 엔티티 반환

      * 이미 영속성 컨텍스트에 엔티티가 있으면 1차캐싱으로 실제 엔티티가 조회
      * JPA에서는 == 비교는 같은 영속성 컨텍스트 트랜잭션 레벨 안에 있다면 모두 True를 보장해주기에  같은 엔티티가 나옵니다.
      * 영속성 컨텍스트에 프록시로 조회하고 두번째도 프록시 조회한다면 당연 둘다 프록시 객체
      * 처음 영속성 컨텍스트 프록시를 조회해회고 두번째에 엔티티를 조회한다면 이것또한 같은 영속성컨텍스트 안에 있기에 프록시객체가 나오게 됩니다.

      ~~~java
      em.reference()
      em.find()
      ref == find // <- 같은 영속성 컨텍스트 트랜잭션 레벨일 경우 == 비교는 true를 보장해야하기에 둘다 프록시를 가져옵니다.
      ~~~

      * **영속성 컨텍스트의 도움을 받을 수 없는 준영속성 상태일때 프록시를 초기화  할 경우 에러를 발생**

      ~~~java
      Member refMember = em.getReference(); // 프록시 객체 조회
      em.detach(refMember); // 준 영속성 상태 영속성컨텍스트에서 분리
      refMember.getName(); // 프록시를 통한 지연 로딩시 에러 발생 -> could not initalize proxy 영속성 컨텍스트를 통한 프록시 사용 못합니다.
      ~~~

      

