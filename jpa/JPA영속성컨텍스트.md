# JPA 영속성컨텍스트

* entityManagerFactory를 통해 요청이 오면 entityManager를 생성한다. 엔티티매니저는 데이터 커넥션을 통해 디비를 사용하게된다.

* JPA는 리플렉션 같이 동적으로 엔티티객체를 생성하기에 기본 생성자가 필요합니다.

* ### 영속성 컨텍스트

  * 엔티티를 영구 저장하는 환경
  * EntityManager.persist(entity) -> persist 메서드는 db에 저장하는게 아니라 영속성컨텍스트에 저장하는 메서드
  * 엔티티매니저를 통해 영속성 컨텍스트에 접근
  * **엔티티의 생명주기**

  | 비영속성(new)    | 영속성 컨텍스트와 관계없는 새로운 상태.  new Member();       |
  | ---------------- | ------------------------------------------------------------ |
  | 영속(managed)    | 영속성 컨텍스트에 관리.  em.persist(member); // EntityManger.persist |
  | 준영속(detached) | 영속성 컨텍스에 저장되엇다 분리.  em.detached(member)        |
  | 삭제(removed)    | 삭제된 상태.   em.remove(member)                             |

  = **영속성컨텍스트라는 중간 계층을 두어 1차캐시, 동일성, 트랜잭션 쓰기 지연, 변경감지, 지연로딩의 이점을 얻을 수 있다.**

* 1차 캐시
  * 키값은 pk 값은 객체 자체이다. -> 조회시 db조회 이전 영속성 컨텍스트 내부에 있는 키값을 찾아 조회한다.
  * 조회된값이 없다면 디비를 조회해 찾은 값에 값을 영속성컨텍스트 1차캐시에 넣는다.
  * **하지만 트랜잭션 단위로 서비스를 구현하기에 성능 이점에 도움이 크지않는다.**

* 동일성보장

  * 같은 트랜잭션안에 객체는 같은 주소를 가리키는것과 같음

  ~~~java
  Member a = em.find(Member.class,"member1");
  Member b = em.find(Member.class,"member1");
  a==b // true
  ~~~

* 트랜잭션이 지원하는 쓰기 지연

  * 영속성컨텍스트에 관리될때 1차캐시에 넣고 / 쓰기지연 SQL저장소라는곳에 insert sql생성해 넣는다.
  * commit시 -> flush하여 insert query가 전송된다.

  ~~~java
  em.persist(memberA);
  em.persist(memberB);
  // insert 쿼리 나가지 않음
  transaction.commit() // 엔티티매니저 트랜잭션 커밋시 쿼리가 나갑니다.
  ~~~

  * 쓰기 지연으로 인한 이점 -> 한번에 쿼리를 보낼수있다.

  ~~~xml
  <property name="hibernate.jdbc.batch.size" value="10"> // 위 사이즈만큼 모아서 한번에 보낼수있다.
  ~~~

* 변경감지 (dirtyChecking)

  * JPA는 자바 컬렉션과 같이 사용이 가능해 엔티티 자체에 값을 변경 후 다시 데이터베이스에 접근해 반영해주지 않아도된다.
    * **컬렉션 set메서드 호출후 value값 변경한 다음 다시 값을 집어넣지 않는것과같다**
  * JPA는 commit시 flush메서드 호출이되어 엔티티와 1차캐시내에 스냅샷을 비교  
    *  최근 데이터에 값을 조회해온 값을 스냅샷을 저장해 엔티티객체와 비교해 값이 달라졋을 경우 update쿼리가 나간다.

  ~~~java
  em.find(Member.class,1L);
  Member.setName("change"); // 변경 감지로 업데이트 쿼리가 나감
  // em.updatae(member) <- 이런코드 필요없습니다.
  ~~~

* ### 플러시

  * 영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 작업(crud)
  * 플러시하여도 1차캐시가 지워지는건 아닙니다. 등록수정삭제 쿼리가 데이터베이스에 반영되는 작업
  * **영속성 컨텍스트를 비우는게 아니다!**
  * 영속성 컨텍스트 변경내용을 데이터베이스에 동기화하는것
  * 플러시하는방법
    * em.flush() : 플러시직접호출 , 트랜잭션 커밋 , JPQL쿼리실행 -> 자동호출

* ### 준영속 상태

  * 영속 -> 준영속 detached
  * 영속성 컨텍스트가 제공하는 기능을 사용 못함 (더디 체킹 쓰기지연 1차캐시...)
  * 준영속 만드는방법
    * detached(entity) : 특정 엔티티만 준영속 
    * clear() : 영속성 컨텍스트 전체 초기화
    * close() : 영속성 컨텍스트 종료
