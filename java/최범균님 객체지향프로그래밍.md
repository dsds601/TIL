# 객체지향프로그래밍 입문

* 개발자가 많아지고 배포가 많아질수록 코드를 작성하는 시간이 오래걸린다.
  * 코드가 난잡하고 여러 개발자들이 코드를 작성하다보니 코드를 분석하는 시간 안 좋은 코드 변경으로 인해 비용이 증가한다.
    * **코드 분석시간 증가 , 코드 변경 시간 증가**

* 소프트웨어의 유지보수는 변화하면서 유용하게 변경이 되어야한다.

  * 낮은 비용으로 변화를 할 수 있어야한다. (캡슐화 + 다형성)

* ### 객체

  * 절차지향

    * 흔히 데이터를 여러 프로시저가 공유하는걸 말합니다.

    ~~~java
    // 인증 API
    Account account = findOne(id);
    if (account.getState() == DELETED) {
    
    }
    // 요구 사항으로인해 변경
    Account account = findOne(id);
    if (account.getState() == DELETED || account.getBlockCount() > 0) {
    
    }
    ~~~

    * 데이터를 직접 사용하기에 요구사항이 추가 될 수록 코드가 복잡해지고 수정이 어려워지게 된다.

  * 객체지향

    * 프로시저와 데이터를 묶어서 객체를만듭니다. 객체끼리 서로 다른 데이터를 바로 접근하지 못합니다.
    * 객체끼리 서로 프로시저를 불러서 연결하여 객체를 사용하게 됩니다.



* **객체란**

  * 객체의 핵심 -> 기능제공

  * 객체는 제공하는 기능으로 정의

    * 내부적으로 가진 필드(데이터)로 정의하지 않음

  * 예 : 회원 객체

    * 암호 변경 , 차단 여부 확인

  * 예 : 소리제어기

    * 소리크기 증가 감소기능

  * **기능 명세**

    * 메서드를 이용해서 기능명세
      * 이름 , 파라미터 결과로 구성

    ~~~java
    public class VolumeController {
    	public void increase (int inc) {} // 메서드 이용하여 명세
    }
    ~~~

  * 객체와 객체는 기능을 사용해서 연결 

    * 기능사용 = 메서드 호출

    ~~~java
    VolumeController volCount = new VolumeController();
    volCount.increase(4);
    ~~~

  * **용어 : 메시지**

    * 객체와 객체 상호 작용 : 메서드를 호출 하는 메시지 , 리턴 메시지 , 익셉션 메시지 ...

  * 필드와 get set 메서드만 잇고 기능은 없는건 객체일까?
    * **아니다 기능이 없으므로 객체가 아니라 구조체 그냥 데이터이다.**
    * **객체는 기능을 정의하고 있어야 한다.**


### 캡슐화 (정보은닉 포함)

* 데이터 + 관련기능 묶는걸 캡슐화라고 한다.
* 객체에 기능을 외부에 감추는것 -> 정보 은닉
* **가장 큰 이유 : 외부에 영향 없이 객체 내부구현 변경 가능**



* **캡슐화를 이용하지 않으면**
* 위 와 같이 정회원 기능을 실행하는 코드가 한곳이 아니기에 사용하는 메서드를 찾아 모두 변경해줘야한다.
* 요구 사항에 변화에 따라 데이터 구조 사용에 변화를 발생시킴

~~~java
if(acc.getMembership() == REGULAR && acc.getExpDate().isAfter(now*())){
	// 정회원 기능 실행 -> 레귤러 등급에 만료일이 지나지않앗다면
}
// 기능 추가 5년이상 사용자 일부 기능 제공

if(acc.getMembership() == REGULAR && 
(
(acc.getServiceDate().isAfter(fiveEayer) && agg.getExpDate().isAfter(now()))
	){
	// 정회원 기능 실행 -> 레귤러 등급에 만료일이 지나지않앗다면
}
~~~



* **캡슐화를 이용하면**
* 여러 코드를 수정하지 않고 Account클래스에 메서드만 변경하면 코드를 사용하는 외부 코드는 변경하지 않고 내부 코드만 변경하면 된다.
* 연쇄적인 변경 전파를 최소화 할 수 있다.

~~~java
if(acc.hasRegularPermission()){
	정회원 기능
}

public class Account {
	public boolean hasRegularPermission(){
		return membership == REGULAR && expDate.isAfter(now())
	}
}
~~~



* 캡슐화시도 -> 기능에 대한 (의도) 이해를 높임

  * 멤버십이 왜 REGULAR로 정의하는 이유? -> 권한을 확인하는지 체크하며 비즈니스 로직을 조금 더 생각하게 된다.

* **캡슐화를 위한 규칙**

  1. **Tell , Don't Ask**

  * 데이터를 달라 하지 말고 해달라고 하기 
  * (데이터를 가져와서 판단하지말고 데이터를 가지고 있는 대상에게 해달라고 하기)

  ~~~java
  if(acc.getMembership() == REGULAR) {
  		정회원 기능
  }
  // =>
  if(acc.hasRegularPermission()) {
  		정회원 기능
  }
  ~~~

  2. **Demeter's Law**

     * 메서드에서 생성한 객체의 메서드만 호출
     * 파라미터로 받은 객체의 메서드만 호출
     * 필드로 참조하는 객체의 메서드만 호출

     ~~~java
     acc.getExpDate().isAfter(now) // -> acc.isExpired()
       
     Date date = acc.getExpDate();  //-> acc.isValid(now)
     date.isAfter(now);
     ~~~

* **캡슐화 정리**

  * 캡슐화 : 기능을 외부에 감춤
  * 캡슐화를 통해 기능을 사용하는 코드에 영향을 최소화 하여 내부 코드에 변경으로 인해 전체 코드가 변경되는 유연함을 발생시켜 비용을 최소화 한다.

### 캡슐화 연습

* 캡슐화를 위한 규칙을 잊지말자

  * Tell Don't Ask . 

    * 데이터를 가져와서 판단 하지 말고 객체가 판단을 하자

    ~~~java
    // > 변경 전
    if(mem.getVerificationEmailStatus() != 2) { // <- Member 객체가 판단하자
    	return AuthResult.NO_EMAIL;
    }
    
    //-> 객체가 판단하자
    class Member {
    	public boolean isEmailVerificated() {
    		return verificationEmailStatus == 2;
    	}
    }
    // > 변경 후
    if(mem.isEmailVerificated()) { // <- Member 객체가 판단하자
    	return AuthResult.NO_EMAIL;
    }
    ~~~

  * 객체를 생성해서 자주 사용하는 기능을 객체 내부에 넣어 파라미터를 받아 사용하면 비용이 적게  사용할 수 있다.

  * 데이터를 받은후 수정 하는 로직이 있는경우에는 아예 기능 자체를 객체 내부에 정의해서 캡슐화 하여 사용하는게 더 좋을 수 있다.~

    ~~~java
    class Member {
    	public void verifyEmail(){
        if(~~~) {
    
        } else {
          this.~~ =2 ; //데이터 수정
        }
    	}
    }
    
    if(mem == null) throw new ~~();
    mem.veriftyEmail() // 변경
    ~~~

